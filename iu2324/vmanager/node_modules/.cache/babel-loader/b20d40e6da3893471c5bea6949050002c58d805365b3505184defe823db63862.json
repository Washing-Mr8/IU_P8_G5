{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport * as U from './util.js';\nclass State {\n  /**\r\n   * A full model of the internal state.\r\n   * @param {string} name \r\n   * @param {[Vm]} vms \r\n   * @param {[Group]} groups \r\n   * @param {[File]} files \r\n   */\n  constructor(name, vms, groups, files) {\n    this.name = name;\n    this.vms = vms;\n    this.groups = groups;\n    this.files = files;\n  }\n}\nclass Vm {\n  /**\r\n   * A Virtual Machine.\r\n   * @param {number} id\r\n   * @param {string} name\r\n   * @param {number} ram in Gb\r\n   * @param {number} hd in Gb\r\n   * @param {number} cpu as a percentage\r\n   * @param {number} cores\r\n   * @param {string} ip as a v4 aaa.bbb.ccc.ddd string\r\n   * @param {number} up in Kbps\r\n   * @param {number} down in Kbps\r\n   * @param {number} iso, the id of ISO file in drive, or -1 for none\r\n   * @param {VmState} state (\"RUNNING\", \"STOPPED\", or \"SUSPENDED\")\r\n   * @param {number} disk, the id of a file with disk contents, or -1 for none\r\n   * @param {number} memory, the id of a file with memory contents, or -1 for none\r\n   * @param {[number]} groups, ids of groups for this vm\r\n   */\n  constructor(id, name, ram, hd, cpu, cores, ip, up, down, iso, state, disk, memory, groups) {\n    this.id = +id;\n    this.name = name;\n    this.ram = ram;\n    this.hd = hd;\n    this.cpu = cpu;\n    this.cores = cores;\n    this.ip = ip;\n    this.up = up;\n    this.down = down;\n    this.iso = iso;\n    this.state = state;\n    this.disk = disk;\n    this.memory = memory;\n    this.groups = groups || [];\n  }\n}\nclass Group {\n  /**\r\n   * Groups VMs and/or groups. Groups may not contain themselves, \r\n   * either directly or indireclty.\r\n   * @param {number} id\r\n   * @param {string} name\r\n   * @param {[number]} members (ids of contained Vms & Groups)\r\n   */\n  constructor(id, name, members) {\n    this.id = +id;\n    this.name = name;\n    this.members = members || [];\n  }\n}\nclass File {\n  /** \r\n   * Represents a storage file. Used for OVAs (import/export),\r\n   * disk contents, ram dumps (suspend), and ISOs.\r\n   * @param {number} id \r\n   * @param {string} name \r\n   * @param {FileType} type \r\n   * @param {number} size in bytes\r\n   */\n  constructor(id, name, type, size) {\n    this.id = +id;\n    this.name = name;\n    this.type = type;\n    this.size = size;\n  }\n}\n\n/**\r\n * Possible Vm states.\r\n */\nconst VmState = {\n  RUNNING: 'funcionando',\n  STOPPED: 'apagada',\n  SUSPENDED: 'suspendida'\n};\n\n/**\r\n * Possible file types\r\n */\nconst FileType = {\n  ISO: 'iso',\n  OVA: 'ova',\n  MEMORY: 'memoria',\n  DISK: 'disco'\n};\nclass Util {\n  /**\r\n   * Genera muchas Vms al azar\r\n   */\n  static randomVms(n, startId) {\n    const prefixes = new Map();\n    return U.fill(n, () => Util.randomVm(startId++, prefixes));\n  }\n  static randomVm(id, prefixes) {\n    const name = U.unique(U.randomChoice(U.lakeNames), prefixes);\n    const G = 1024; // in Mb\n    const ram = U.randomInRange(1, 128);\n    const hd = U.randomInRange(1, 4 * G);\n    const cpu = U.randomInRange(5, 100);\n    const cores = U.randomInRange(1, 6);\n    const ip = U.generateIp();\n    const up = U.randomInRange(1, 1 * G);\n    const down = U.randomInRange(1, 1 * G);\n    const state = U.randomChoice([...Object.values(VmState)]);\n    return new Vm(id, name, ram, hd, cpu, cores, ip, up, down, -1, state, -1, -1);\n  }\n  static randomGroup(id, prefixes) {\n    const name = U.unique(U.randomChoice(U.simpsonsNames), prefixes);\n    return new Group(id, name);\n  }\n  static populate(nVms, nGroups, nFiles) {\n    const vms = Util.randomVms(nVms, lastId);\n    lastId += nVms;\n    const groupsMap = new Map();\n    const groups = U.fill(nGroups, () => Util.randomGroup(lastId++, groupsMap));\n    for (let g of groups) {\n      for (let v of vms) {\n        if (Math.random() < .2) {\n          g.members.push(v.id);\n          v.groups.push(g.id);\n        }\n      }\n    }\n    const files = [];\n    const fileNames = U.randomSample(U.osNames, Math.min(U.osNames.length, nFiles));\n    const MB = 1024 * 1024;\n    for (let f of fileNames) {\n      files.push(new File(lastId++, f + \".iso\", FileType.ISO, U.randomInRange(1 * MB, 19 * MB)));\n    }\n    return new State(\"VMs Autogeneradas\", vms, groups, files);\n  }\n}\n\n// cache de IDs\n// (se llena vía getId, y se consulta vía resolve, que sí es público; \n//  modificado en métodos de tipo add, rm y set)\nlet cache = new Map();\n// ultimo ID usado (incrementado en métodos de tipo addAlgo)\nlet lastId = 0;\n// el estado global (modificado en métodos de la API tipo add, rm, y set )\nlet state = new State();\n\n/**\r\n * Inicializa el estado a uno dado o, si no se especifica, uno generado al azar\r\n * \r\n * @param {State} [newState] \r\n */\nfunction init(newState) {\n  state = updateState(newState);\n  console.log(\"inicializado!\", state);\n  return state;\n}\n\n/**\r\n * Devuelve el objeto (User, Course, Edition, ó Result) con esa id\r\n * @param {number} id a buscar\r\n * @returns {(User|Course|Edition|Result|undefined)} \r\n */\nfunction resolve(id) {\n  if (!cache.has(+id)) {\n    throw Error(\"ID not found: \" + id);\n  }\n  return U.clone(cache.get(+id));\n}\n\n// acceso y refresco de la cache de IDs\n// privado\nfunction getId(id, object, overwrite) {\n  const found = cache.has(id);\n  if (object) {\n    if (found && !overwrite) {\n      const old = JSON.stringify(cache.get(+id));\n      const cur = JSON.stringify(object);\n      throw Error(`duplicate ID ${id}; old '${old}', new '${cur}'`);\n    }\n    cache.set(+id, object);\n  } else {\n    if (!found) throw Error(\"ID not found: \" + id);\n    return cache.get(+id);\n  }\n}\n\n// refresca cachés\n// privado\nfunction updateState(newState) {\n  cache = new Map();\n  // si no se especifica un estado, se inventa uno nuevo\n  const s = newState || Util.populate(40, 10, 20);\n  s.vms.forEach(o => getId(o.id, o));\n  s.groups.forEach(o => getId(o.id, o));\n  s.files.forEach(o => getId(o.id, o));\n  console.log(\"Updated state\", s);\n  return s;\n}\n\n/**\r\n * Salva el estado actual, y permite recuperarlo via restoreState\r\n * @returns {string} token\r\n */\nfunction saveState() {\n  const randomToken = U.randomString(8);\n\n  // add token to stack\n  let stack = localStorage.getItem('stack');\n  if (!stack) {\n    stack = [];\n  } else {\n    stack = JSON.parse(stack);\n  }\n  stack.push(randomToken);\n  localStorage.setItem('stack', JSON.stringify(stack));\n  console.log(`copia guardada ${randomToken}; copias de seguridad existentes`, stack);\n  localStorage.setItem(randomToken, JSON.stringify(state));\n  return randomToken;\n}\n\n/**\r\n * Restaura un estado previamente guardado\r\n * @param {string} token \r\n */\nfunction restoreState(token) {\n  // if no token specified, pop token from stack\n  let stack = localStorage.getItem('stack');\n  if (!token) {\n    if (!stack) {\n      stack = [];\n    } else {\n      stack = JSON.parse(stack);\n    }\n    if (!stack.length) {\n      throw Error(\"No token specified, and state-stack is empty\");\n    } else {\n      token = stack.pop();\n      localStorage.setItem('stack', JSON.stringify(stack));\n    }\n  }\n  console.log(`restaurada: ${token}; copias de seguridad existentes`, stack);\n  state = updateState(JSON.parse(localStorage.getItem(token)));\n}\n\n/**\r\n * Devuelve (copias) de vms\r\n */\nfunction getVms(pattern) {\n  const r = pattern ? state.vms.filter(o => U.sameAs(o, pattern)) : state.vms;\n  return U.clone(r);\n}\n\n/**\r\n * Devuelve (copias) de grupos\r\n */\nfunction getGroups(pattern) {\n  const r = pattern ? state.groups.filter(o => U.sameAs(o, pattern)) : state.groups;\n  return U.clone(r);\n}\n\n/**\r\n * Devuelve (copias) de archivos\r\n */\nfunction getFiles(pattern) {\n  const r = pattern ? state.files.filter(o => U.sameAs(o, pattern)) : state.files;\n  return U.clone(r);\n}\n\n/**\r\n * elimina una VM del sistema\r\n */\nfunction rmVm(vmId) {\n  console.log(`removing vm ${vmId}`);\n  if (!cache.has(+vmId)) {\n    throw Error(`Cannot rm with id ${vmId}: not found`);\n  }\n\n  // elimina de vms    \n  const removals = U.rmWhere(state.vms, o => o.id == vmId);\n  if (removals != 1) {\n    throw Error(`Expected 1 removal, but did ${removals}`);\n  }\n\n  // elimina menciones en grupos\n  for (let g of state.groups) {\n    U.rmWhere(g.members, o => o == vmId);\n  }\n\n  // regenera cachés: cosas pueden haber sido borradas\n  state = updateState(state);\n}\n\n/**\r\n * elimina un grupo del sistema\r\n */\nfunction rmGroup(groupId) {\n  console.log(`removing group ${groupId}`);\n  if (!cache.has(+groupId)) {\n    throw Error(`Cannot rm group with id ${groupId}: not found`);\n  }\n\n  // elimina de grupos\n  const removals = U.rmWhere(state.groups, o => o.id == groupId);\n  if (removals != 1) {\n    throw Error(`Expected 1 removal, but did ${removals}`);\n  }\n\n  // elimina menciones en vms\n  for (let vm of state.vms) {\n    U.rmWhere(vm.groups, o => o == groupId);\n  }\n  // elimina menciones en grupos\n  for (let g of state.groups) {\n    U.rmWhere(g.members, o => o == groupId);\n  }\n\n  // regenera cachés: cosas pueden haber sido borradas\n  state = updateState(state);\n}\n\n/**\r\n * modifica una vm\r\n */\nfunction setVm(vm) {\n  if (!cache.has(vm.id)) {\n    throw Error(`Cannot set vm with id ${vm.id}: not found`);\n  }\n  console.log(\"reemplazando \", resolve(vm.id), \"con\", vm);\n  const oldGroups = getId(vm.id).groups;\n  const dropped = U.inOneButNotAnother(oldGroups, vm.groups);\n  const joined = U.inOneButNotAnother(vm.groups, oldGroups);\n\n  // reemplaza en vms\n  U.doWhere(state.vms, o => o.id == vm.id, (a, i) => a[i] = vm);\n\n  // actualiza grupos\n  for (let g of dropped) {\n    U.rmWhere(getId(g).members, o => o == vm.id);\n  }\n  for (let g of joined) {\n    getId(g).members.push(vm.id);\n  }\n\n  // reemplaza en cache\n  getId(vm.id, vm, true);\n}\n\n/**\r\n * modifica un grupo\r\n */\nfunction setGroup(g) {\n  if (!cache.has(g.id)) {\n    throw Error(`Cannot set group with id ${g.id}: not found`);\n  }\n  console.log(\"reemplazando \", resolve(g.id), \"con\", g);\n  const oldMembers = getId(g.id).members;\n  const dropped = U.inOneButNotAnother(oldMembers, g.members);\n  const joined = U.inOneButNotAnother(g.members, oldMembers);\n\n  // reemplaza en groups\n  U.doWhere(state.groups, o => o.id == g.id, (a, i) => a[i] = g);\n\n  // actualiza en listas de grupos de vms\n  for (let v of dropped) {\n    U.rmWhere(getId(v).groups, o => o == g.id);\n  }\n  for (let v of joined) {\n    getId(v).groups.push(g.id);\n  }\n\n  // reemplaza en cache\n  getId(g.id, g, true);\n}\n\n/**\r\n * añade una vm; ignora el ID para asignarle otro nuevo\r\n * @param {Vm} vm \r\n */\nfunction addVm(vm) {\n  console.log(\"añadiendo \", vm);\n  const newVm = new Vm(lastId++, vm.name, +vm.ram, +vm.hd, +vm.cpu, +vm.cores, vm.ip, +vm.up, +vm.down, vm.iso, vm.state, +vm.disk, +vm.memory, vm.groups);\n  getId(newVm.id, newVm, false);\n  state.vms.push(newVm);\n  return newVm;\n}\n\n/**\r\n * añade un grupo; ignora el ID para asignarle otro nuevo\r\n * @param {Group} g \r\n */\nfunction addGroup(g) {\n  console.log(\"añadiendo \", g);\n  const newGroup = new Group(lastId++, g.name, g.members);\n  getId(newGroup.id, newGroup, false);\n  state.groups.push(newGroup);\n  return newGroup;\n}\n\n/**\r\n * Enciende todas las máquinas virtuales de un grupo.\r\n * @param {number} groupId - ID del grupo.\r\n */\nfunction turnOnAll(groupId) {\n  const group = resolve(groupId);\n  if (!group || !Array.isArray(group.members)) {\n    throw new Error(`Invalid group ID: ${groupId}`);\n  }\n  group.members.forEach(vmId => {\n    const vm = resolve(vmId);\n    if (vm && vm.state !== VmState.RUNNING) {\n      setVm({\n        ...vm,\n        state: VmState.RUNNING\n      });\n    }\n  });\n}\nfunction turnOffAll(groupId) {\n  const group = resolve(groupId);\n  if (!group || !Array.isArray(group.members)) {\n    throw new Error(`Invalid group ID: ${groupId}`);\n  }\n  group.members.forEach(vmId => {\n    const vm = resolve(vmId);\n    if (vm && vm.state !== VmState.STOPPED) {\n      setVm({\n        ...vm,\n        state: VmState.STOPPED\n      });\n    }\n  });\n}\n\n// cosas que estarán disponibles desde fuera de este módulo\n// todo lo que NO se mencione aquí es privado (= inaccesible) desde fuera\n// podríamos haber evitado esto añadiendo `export` a todas las funciones \"públicas\"\nexport { State,\n// estado de la aplicación; incluye todas las instancias de las siguientes entidades\n// Entidades\nVm, Group, File,\n// Enums\nVmState, FileType,\n// salva el estado actual (a localStorage; devuelve ID asignado)\nsaveState,\n// restaura un estado previamente guardado\nrestoreState,\n// NOTA: para añadir o eliminar vms o grupos de grupos, \n//   usa setGroup y modifica las listas de IDs de members\n//   o usa setVm y modifica las listas de IDs de groups\ngetVms, getGroups, getFiles, addVm, setVm, rmVm, addGroup, setGroup, rmGroup, turnOnAll, turnOffAll,\n// general\ninit,\n// inicializa el estado; llama para no operar con un modelo vacío\nresolve // devuelve un objeto, por ID\n};","map":{"version":3,"names":["U","State","constructor","name","vms","groups","files","Vm","id","ram","hd","cpu","cores","ip","up","down","iso","state","disk","memory","Group","members","File","type","size","VmState","RUNNING","STOPPED","SUSPENDED","FileType","ISO","OVA","MEMORY","DISK","Util","randomVms","n","startId","prefixes","Map","fill","randomVm","unique","randomChoice","lakeNames","G","randomInRange","generateIp","Object","values","randomGroup","simpsonsNames","populate","nVms","nGroups","nFiles","lastId","groupsMap","g","v","Math","random","push","fileNames","randomSample","osNames","min","length","MB","f","cache","init","newState","updateState","console","log","resolve","has","Error","clone","get","getId","object","overwrite","found","old","JSON","stringify","cur","set","s","forEach","o","saveState","randomToken","randomString","stack","localStorage","getItem","parse","setItem","restoreState","token","pop","getVms","pattern","r","filter","sameAs","getGroups","getFiles","rmVm","vmId","removals","rmWhere","rmGroup","groupId","vm","setVm","oldGroups","dropped","inOneButNotAnother","joined","doWhere","a","i","setGroup","oldMembers","addVm","newVm","addGroup","newGroup","turnOnAll","group","Array","isArray","turnOffAll"],"sources":["C:/hlocal/IU_P8_G5/IU_P8_G5/iu2324/vmanager/src/model.js"],"sourcesContent":["import * as U from './util.js';\r\n\r\nclass State {\r\n    /**\r\n     * A full model of the internal state.\r\n     * @param {string} name \r\n     * @param {[Vm]} vms \r\n     * @param {[Group]} groups \r\n     * @param {[File]} files \r\n     */\r\n    constructor(name, vms, groups, files) {\r\n        this.name = name;\r\n        this.vms = vms;\r\n        this.groups = groups;\r\n        this.files = files;\r\n    }\r\n}\r\n\r\nclass Vm {\r\n    /**\r\n     * A Virtual Machine.\r\n     * @param {number} id\r\n     * @param {string} name\r\n     * @param {number} ram in Gb\r\n     * @param {number} hd in Gb\r\n     * @param {number} cpu as a percentage\r\n     * @param {number} cores\r\n     * @param {string} ip as a v4 aaa.bbb.ccc.ddd string\r\n     * @param {number} up in Kbps\r\n     * @param {number} down in Kbps\r\n     * @param {number} iso, the id of ISO file in drive, or -1 for none\r\n     * @param {VmState} state (\"RUNNING\", \"STOPPED\", or \"SUSPENDED\")\r\n     * @param {number} disk, the id of a file with disk contents, or -1 for none\r\n     * @param {number} memory, the id of a file with memory contents, or -1 for none\r\n     * @param {[number]} groups, ids of groups for this vm\r\n     */\r\n    constructor(id, name, ram, hd, cpu, cores, ip, up, down, \r\n            iso, state, disk, memory, groups) {\r\n        this.id = +id;\r\n        this.name = name;\r\n        this.ram = ram;\r\n        this.hd = hd;\r\n        this.cpu = cpu;\r\n        this.cores = cores;\r\n        this.ip = ip;\r\n        this.up = up;\r\n        this.down = down;\r\n        this.iso = iso;\r\n        this.state = state;\r\n        this.disk = disk;\r\n        this.memory = memory;\r\n        this.groups = groups || [];\r\n    }\r\n}\r\n\r\nclass Group {\r\n    /**\r\n     * Groups VMs and/or groups. Groups may not contain themselves, \r\n     * either directly or indireclty.\r\n     * @param {number} id\r\n     * @param {string} name\r\n     * @param {[number]} members (ids of contained Vms & Groups)\r\n     */\r\n    constructor(id, name, members) {\r\n        this.id = +id;\r\n        this.name = name;\r\n        this.members = members || [];\r\n    }\r\n}\r\n\r\nclass File {\r\n    /** \r\n     * Represents a storage file. Used for OVAs (import/export),\r\n     * disk contents, ram dumps (suspend), and ISOs.\r\n     * @param {number} id \r\n     * @param {string} name \r\n     * @param {FileType} type \r\n     * @param {number} size in bytes\r\n     */\r\n    constructor(id, name, type, size) {\r\n        this.id = +id;\r\n        this.name = name;\r\n        this.type = type;\r\n        this.size = size;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Possible Vm states.\r\n */\r\nconst VmState = {\r\n    RUNNING: 'funcionando', \r\n    STOPPED: 'apagada',\r\n    SUSPENDED: 'suspendida', \r\n}\r\n\r\n/**\r\n * Possible file types\r\n */\r\nconst FileType = {\r\n    ISO: 'iso',\r\n    OVA: 'ova',\r\n    MEMORY: 'memoria',\r\n    DISK: 'disco',\r\n}\r\n\r\nclass Util {\r\n\r\n    /**\r\n     * Genera muchas Vms al azar\r\n     */\r\n    static randomVms(n, startId) {\r\n        const prefixes = new Map();\r\n        return U.fill(n, () => Util.randomVm(startId++, prefixes));\r\n    }\r\n\r\n    static randomVm(id, prefixes) {\r\n        const name = U.unique(U.randomChoice(U.lakeNames), prefixes)        \r\n        const G = 1024; // in Mb\r\n        const ram = U.randomInRange(1,128);\r\n        const hd = U.randomInRange(1, 4*G);\r\n        const cpu = U.randomInRange(5, 100);\r\n        const cores = U.randomInRange(1, 6);\r\n        const ip = U.generateIp();\r\n        const up = U.randomInRange(1, 1*G);\r\n        const down = U.randomInRange(1, 1*G);\r\n        const state = U.randomChoice([...Object.values(VmState)]);\r\n        return new Vm(id, name, ram, hd, cpu, cores, ip, up, down, -1, state, -1, -1);\r\n    }\r\n\r\n    static randomGroup(id, prefixes) {\r\n        const name = U.unique(U.randomChoice(U.simpsonsNames), prefixes)        \r\n        return new Group(id, name);\r\n    }\r\n\r\n    static populate(nVms, nGroups, nFiles) {\r\n        const vms = Util.randomVms(nVms, lastId);\r\n        lastId += nVms;\r\n        const groupsMap = new Map();\r\n        const groups = U.fill(nGroups, () => Util.randomGroup(lastId++, groupsMap));\r\n        for (let g of groups) {\r\n            for (let v of vms) {\r\n                if (Math.random() < .2) {\r\n                    g.members.push(v.id);\r\n                    v.groups.push(g.id);\r\n                }\r\n            }\r\n        }\r\n\r\n        const files = [];\r\n        const fileNames = U.randomSample(U.osNames, Math.min(U.osNames.length, nFiles));\r\n        const MB = 1024*1024;\r\n        for (let f of fileNames) {\r\n            files.push(new File(lastId++, f+\".iso\", FileType.ISO, U.randomInRange(1*MB, 19*MB)));\r\n        }\r\n        return new State(\"VMs Autogeneradas\", vms, groups, files);\r\n    }\r\n}\r\n\r\n// cache de IDs\r\n// (se llena vía getId, y se consulta vía resolve, que sí es público; \r\n//  modificado en métodos de tipo add, rm y set)\r\nlet cache = new Map();\r\n// ultimo ID usado (incrementado en métodos de tipo addAlgo)\r\nlet lastId = 0;\r\n// el estado global (modificado en métodos de la API tipo add, rm, y set )\r\nlet state = new State();\r\n\r\n/**\r\n * Inicializa el estado a uno dado o, si no se especifica, uno generado al azar\r\n * \r\n * @param {State} [newState] \r\n */\r\nfunction init(newState) {\r\n    state = updateState(newState);\r\n    console.log(\"inicializado!\", state);\r\n    return state;\r\n}\r\n\r\n/**\r\n * Devuelve el objeto (User, Course, Edition, ó Result) con esa id\r\n * @param {number} id a buscar\r\n * @returns {(User|Course|Edition|Result|undefined)} \r\n */\r\nfunction resolve(id) {\r\n    if (!cache.has(+id)) {\r\n        throw Error(\"ID not found: \" + id);\r\n    }\r\n    return U.clone(cache.get(+id));\r\n}\r\n\r\n// acceso y refresco de la cache de IDs\r\n// privado\r\nfunction getId(id, object, overwrite) {\r\n    const found = cache.has(id);\r\n    if (object) {\r\n        if (found && !overwrite) {\r\n            const old = JSON.stringify(cache.get(+id));\r\n            const cur = JSON.stringify(object);\r\n            throw Error(`duplicate ID ${id}; old '${old}', new '${cur}'`);\r\n        }\r\n        cache.set(+id, object);\r\n    } else {\r\n        if (!found) throw Error(\"ID not found: \" + id);\r\n        return cache.get(+id);\r\n    }\r\n}\r\n\r\n// refresca cachés\r\n// privado\r\nfunction updateState(newState) {\r\n    cache = new Map();\r\n    // si no se especifica un estado, se inventa uno nuevo\r\n    const s = newState || Util.populate(40, 10, 20);\r\n    s.vms.forEach(o => getId(o.id, o));\r\n    s.groups.forEach(o => getId(o.id, o));\r\n    s.files.forEach(o => getId(o.id, o));\r\n    console.log(\"Updated state\", s);\r\n    return s;\r\n}\r\n\r\n/**\r\n * Salva el estado actual, y permite recuperarlo via restoreState\r\n * @returns {string} token\r\n */\r\nfunction saveState() {\r\n    const randomToken = U.randomString(8);\r\n\r\n    // add token to stack\r\n    let stack = localStorage.getItem('stack');\r\n    if (!stack) {\r\n        stack = [];\r\n    } else {\r\n        stack = JSON.parse(stack);\r\n    }\r\n    stack.push(randomToken);\r\n    localStorage.setItem('stack', JSON.stringify(stack));\r\n    console.log(`copia guardada ${randomToken}; copias de seguridad existentes`, stack);\r\n\r\n    localStorage.setItem(randomToken, JSON.stringify(state));\r\n    return randomToken;\r\n}\r\n\r\n/**\r\n * Restaura un estado previamente guardado\r\n * @param {string} token \r\n */\r\nfunction restoreState(token) {\r\n\r\n    // if no token specified, pop token from stack\r\n    let stack = localStorage.getItem('stack');\r\n    if (!token) {\r\n        if (!stack) {\r\n            stack = [];\r\n        } else {\r\n            stack = JSON.parse(stack);\r\n        }\r\n        if (!stack.length) {\r\n            throw Error(\"No token specified, and state-stack is empty\");\r\n        } else {\r\n            token = stack.pop();\r\n            localStorage.setItem('stack', JSON.stringify(stack));\r\n        }\r\n    }\r\n    console.log(`restaurada: ${token}; copias de seguridad existentes`, stack);\r\n\r\n    state = updateState(JSON.parse(localStorage.getItem(token)));\r\n}\r\n\r\n/**\r\n * Devuelve (copias) de vms\r\n */\r\nfunction getVms(pattern) {\r\n    const r = pattern ?\r\n        state.vms.filter(o => U.sameAs(o, pattern)) :\r\n        state.vms;\r\n    return U.clone(r);\r\n}\r\n\r\n/**\r\n * Devuelve (copias) de grupos\r\n */\r\nfunction getGroups(pattern) {\r\n    const r = pattern ?\r\n        state.groups.filter(o => U.sameAs(o, pattern)) :\r\n        state.groups;\r\n    return U.clone(r);\r\n}\r\n\r\n/**\r\n * Devuelve (copias) de archivos\r\n */\r\nfunction getFiles(pattern) {\r\n    const r = pattern ?\r\n        state.files.filter(o => U.sameAs(o, pattern)) :\r\n        state.files;\r\n    return U.clone(r);\r\n}\r\n\r\n/**\r\n * elimina una VM del sistema\r\n */\r\nfunction rmVm(vmId) {\r\n    console.log(`removing vm ${vmId}`)\r\n    if (!cache.has(+vmId)) {\r\n        throw Error(`Cannot rm with id ${vmId}: not found`);\r\n    }\r\n\r\n    // elimina de vms    \r\n    const removals = U.rmWhere(state.vms, o => o.id == vmId);\r\n    if (removals != 1) {\r\n        throw Error(`Expected 1 removal, but did ${removals}`)\r\n    }\r\n\r\n    // elimina menciones en grupos\r\n    for (let g of state.groups) {\r\n        U.rmWhere(g.members, o => o == vmId);\r\n    }\r\n\r\n    // regenera cachés: cosas pueden haber sido borradas\r\n    state = updateState(state)\r\n}\r\n\r\n/**\r\n * elimina un grupo del sistema\r\n */\r\nfunction rmGroup(groupId) {\r\n    console.log(`removing group ${groupId}`)\r\n    if (!cache.has(+groupId)) {\r\n        throw Error(`Cannot rm group with id ${groupId}: not found`);\r\n    }\r\n\r\n    // elimina de grupos\r\n    const removals = U.rmWhere(state.groups, o => o.id == groupId);\r\n    if (removals != 1) {\r\n        throw Error(`Expected 1 removal, but did ${removals}`)\r\n    }\r\n\r\n    // elimina menciones en vms\r\n    for (let vm of state.vms) {\r\n        U.rmWhere(vm.groups, o => o == groupId);\r\n    }\r\n    // elimina menciones en grupos\r\n    for (let g of state.groups) {\r\n        U.rmWhere(g.members, o => o == groupId);\r\n    }\r\n\r\n    // regenera cachés: cosas pueden haber sido borradas\r\n    state = updateState(state)\r\n}\r\n\r\n/**\r\n * modifica una vm\r\n */\r\nfunction setVm(vm) {\r\n    if (!cache.has(vm.id)) {\r\n        throw Error(`Cannot set vm with id ${vm.id}: not found`);\r\n    }\r\n    console.log(\"reemplazando \", resolve(vm.id), \"con\", vm);\r\n\r\n    const oldGroups = getId(vm.id).groups;\r\n    const dropped = U.inOneButNotAnother(oldGroups, vm.groups);\r\n    const joined = U.inOneButNotAnother(vm.groups, oldGroups);\r\n\r\n    // reemplaza en vms\r\n    U.doWhere(state.vms, o => o.id == vm.id, (a, i) => a[i] = vm);\r\n\r\n    // actualiza grupos\r\n    for (let g of dropped) {\r\n        U.rmWhere(getId(g).members, o => o == vm.id);\r\n    }\r\n    for (let g of joined) {\r\n        getId(g).members.push(vm.id);\r\n    }\r\n\r\n    // reemplaza en cache\r\n    getId(vm.id, vm, true);\r\n}\r\n\r\n/**\r\n * modifica un grupo\r\n */\r\nfunction setGroup(g) {\r\n    if (!cache.has(g.id)) {\r\n        throw Error(`Cannot set group with id ${g.id}: not found`);\r\n    }\r\n    console.log(\"reemplazando \", resolve(g.id), \"con\", g);\r\n\r\n    const oldMembers = getId(g.id).members;\r\n    const dropped = U.inOneButNotAnother(oldMembers, g.members);\r\n    const joined = U.inOneButNotAnother(g.members, oldMembers);\r\n\r\n    // reemplaza en groups\r\n    U.doWhere(state.groups, o => o.id == g.id, (a, i) => a[i] = g);\r\n\r\n    // actualiza en listas de grupos de vms\r\n    for (let v of dropped) {\r\n        U.rmWhere(getId(v).groups, o => o == g.id);\r\n    }\r\n    for (let v of joined) {\r\n        getId(v).groups.push(g.id);\r\n    }\r\n\r\n    // reemplaza en cache\r\n    getId(g.id, g, true);\r\n}\r\n\r\n/**\r\n * añade una vm; ignora el ID para asignarle otro nuevo\r\n * @param {Vm} vm \r\n */\r\nfunction addVm(vm) {\r\n    console.log(\"añadiendo \", vm);\r\n    const newVm = new Vm(lastId++, vm.name, +vm.ram, +vm.hd, +vm.cpu, \r\n        +vm.cores, vm.ip, +vm.up, +vm.down, vm.iso, vm.state, +vm.disk,\r\n        +vm.memory, vm.groups);\r\n    getId(newVm.id, newVm, false);\r\n    state.vms.push(newVm);\r\n    return newVm;\r\n}\r\n\r\n/**\r\n * añade un grupo; ignora el ID para asignarle otro nuevo\r\n * @param {Group} g \r\n */\r\nfunction addGroup(g) {\r\n    console.log(\"añadiendo \", g);\r\n    const newGroup = new Group(lastId++, g.name, g.members);\r\n    getId(newGroup.id, newGroup, false);\r\n    state.groups.push(newGroup);\r\n    return newGroup;\r\n}\r\n\r\n\r\n/**\r\n * Enciende todas las máquinas virtuales de un grupo.\r\n * @param {number} groupId - ID del grupo.\r\n */\r\nfunction turnOnAll(groupId) {\r\n    const group = resolve(groupId);\r\n    if (!group || !Array.isArray(group.members)) {\r\n      throw new Error(`Invalid group ID: ${groupId}`);\r\n    }\r\n  \r\n    group.members.forEach(vmId => {\r\n      const vm = resolve(vmId);\r\n      if (vm && vm.state !== VmState.RUNNING) {\r\n        setVm({ ...vm, state: VmState.RUNNING });\r\n      }\r\n    });\r\n  }\r\n  \r\n\r\n  function turnOffAll(groupId) {\r\n    const group = resolve(groupId);\r\n    if (!group || !Array.isArray(group.members)) {\r\n      throw new Error(`Invalid group ID: ${groupId}`);\r\n    }\r\n  \r\n    group.members.forEach(vmId => {\r\n      const vm = resolve(vmId);\r\n      if (vm && vm.state !== VmState.STOPPED) {\r\n        setVm({ ...vm, state: VmState.STOPPED });\r\n      }\r\n    });\r\n  }\r\n\r\n// cosas que estarán disponibles desde fuera de este módulo\r\n// todo lo que NO se mencione aquí es privado (= inaccesible) desde fuera\r\n// podríamos haber evitado esto añadiendo `export` a todas las funciones \"públicas\"\r\nexport {\r\n\r\n    State, // estado de la aplicación; incluye todas las instancias de las siguientes entidades\r\n    // Entidades\r\n    Vm,\r\n    Group,\r\n    File,\r\n\r\n    // Enums\r\n    VmState,\r\n    FileType,\r\n\r\n    // salva el estado actual (a localStorage; devuelve ID asignado)\r\n    saveState,\r\n    // restaura un estado previamente guardado\r\n    restoreState,\r\n\r\n    // NOTA: para añadir o eliminar vms o grupos de grupos, \r\n    //   usa setGroup y modifica las listas de IDs de members\r\n    //   o usa setVm y modifica las listas de IDs de groups\r\n    getVms,\r\n    getGroups,\r\n    getFiles,\r\n    \r\n    addVm,\r\n    setVm,\r\n    rmVm,\r\n    \r\n    addGroup,\r\n    setGroup,\r\n    rmGroup,\r\n    turnOnAll,\r\n    turnOffAll,\r\n    \r\n    // general\r\n    init, // inicializa el estado; llama para no operar con un modelo vacío\r\n    resolve, // devuelve un objeto, por ID\r\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}